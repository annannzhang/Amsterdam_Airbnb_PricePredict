---
title: "MUSA 508 Final - Amsterdam"
author: 'Ben Keel, Yuhao Sun & Ann (Zian) Zhang'
date: "2022/12/06"
output: 
  html_document:
    theme: lumen
    toc: true
    toc_float: true
    toc_collapsed: true
    code_folding: hide
---

```{r setup, include=FALSE, message = FALSE,warning = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, quiet = TRUE, warning=FALSE)
```
![Amsterdam's Canels, Wikipedia.](https://en.wikipedia.org/wiki/Amsterdam#/media/File:KeizersgrachtReguliersgrachtAmsterdam.jpg)


# Presentation - Youtube Link

Please refer to our presentation video for executive summary of this project/app!

https://youtu.be/6dixtgleyY0


# Background Information -- Amsterdam Airbnb Market

As identified in our video, Amsterdam as a world-class tourism city greets millions of tourists from all over the world. This markdown goes through the technical asspects 


# Data Source

We acquired data from several reliable sources:

Airbnb Data (including price, location, amenities, room compositions, etc.) is acquired from Kaggle, a platform for sharing data set particularly for machine learning. This contains airbnb data in Amsterdam from 2017 December to 2018 December (hence, primarily data for the year of 2018). Although due to the pandemic, tourism in Amsterdam might have undergone changes and variation, this is the best possible data we have available, and we believe it would produce some insights. 
(https://www.kaggle.com/datasets/erikbruin/airbnb-amsterdam?select=listings.csv)

Neighborhood and surrounding amenities data is acquired from City of Amsterdam's online geo data portal, 'Maps Data.' (https://maps.amsterdam.nl/open_geodata/?LANG=en)

In addition, we supplemented data about tourist attrations from 'Tourpedia,' an online data portal with tourism-related data of several European cities. (http://tour-pedia.org/about/datasets.html)

```{r Load R packages, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")

library(tidyverse)
library(sf)
library(RSocrata)
library(viridis)
library(spatstat)
library(ggplot2)
library(raster)
library(spdep)
library(FNN)
library(mapview)
library(grid)
library(gridExtra)
library(knitr)
library(stringr)
library(kableExtra)
library(tidycensus)
library(lubridate)
library(viridis)
library(stargazer)
library(dplyr)
library(plyr)

library(scales)
library(RColorBrewer)
library(gridExtra)
library(ggthemes)
library(readr)
library(ggcorrplot)
library(caret)

library(sjPlot)
library(sjmisc)
library(sjlabelled)
library(osmdata)

#text mining
library(tm)
library(wordcloud2)
library(SnowballC)
options(scipen=999)
```

```{r formatting, include=FALSE, echo = TRUE, message = FALSE, warning = FALSE}

palette5 <- c("#FA8072","#9FE2BF","#FF006A","#FE4C35","#FE9900")
palette4 <- c("#FA8072","#9FE2BF","#FE4C35","#FE9900")
palette2 <- c("#FA8072","#9FE2BF")
Teal <- c("#d1eeea", "#a8dbd9", "#85c4c9", "#68abb8", "#4f90a6")
Purple <- c("#f3e0f7", "#e4c7f1", "#d1afe8", "#b998dd", "#9f82ce")
Pink <- c("#ffffff","#f9f4f4","#f0e4e4", "#e7d3d3", "#dec3c3")

qBr <- function(df, variable, rnd) {
  if (missing(rnd)) {
    as.character(quantile(round(df[[variable]],0),
                          c(.01,.2,.4,.6,.8), na.rm=T))
  } else if (rnd == FALSE | rnd == F) {
    as.character(formatC(quantile(df[[variable]]), digits = 3),
                 c(.01,.2,.4,.6,.8), na.rm=T)
  }
}

qBr2 <- function(df, variable, rnd) {
  if (missing(rnd)) {
    as.character(round(quantile(round(df[[variable]],0),
                          c(.01,.2,.4,.6,.8), na.rm=T)))
  } else if (rnd == FALSE | rnd == F) {
    as.character(round(formatC(quantile(round(df[[variable]]), 0)),
                 c(.01,.2,.4,.6,.8), na.rm=T))
  }
}

q5 <- function(variable) {as.factor(ntile(variable, 5))}

plotTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 14,colour = "black"),
    plot.subtitle = element_text(face="italic"),
    plot.caption = element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_line("grey80", size = 0.1),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.background = element_rect(fill = "grey80", color = "white"),
    strip.text = element_text(size=12),
    axis.title = element_text(size=12),
    axis.text = element_text(size=10),
    plot.background = element_blank(),
    legend.background = element_blank(),
    legend.title = element_text(colour = "black", face = "italic"),
    legend.text = element_text(colour = "black", face = "italic"),
    strip.text.x = element_text(size = 14)
  )
}

mapTheme <- theme(plot.title =element_text(size=12),
                  plot.subtitle = element_text(size=8),
                  plot.caption = element_text(size = 8),
                  axis.line=element_blank(),
                  axis.text.x=element_blank(),
                  axis.text.y=element_blank(),
                  axis.ticks=element_blank(),
                  axis.title.x=element_blank(),
                  axis.title.y=element_blank(),
                  panel.background=element_blank(),
                  panel.border = element_rect(colour = "black", fill=NA, size=2),
                  panel.grid.major=element_line(colour = 'grey92'),
                  panel.grid.minor=element_blank(),
                  legend.direction = "vertical", 
                  legend.position = "right",
                  plot.margin = margin(1, 1, 1, 1, 'cm'),
                  legend.key.height = unit(1, "cm"), legend.key.width = unit(0.2, "cm"))

```

```{r function, include=FALSE, echo = TRUE, message = FALSE, warning = FALSE}
nn_function <- function(measureFrom,measureTo,k) {
  measureFrom_Matrix <- as.matrix(measureFrom)
  measureTo_Matrix <- as.matrix(measureTo)
  nn <-   
    get.knnx(measureTo, measureFrom, k)$nn.dist
  output <-
    as.data.frame(nn) %>%
    rownames_to_column(var = "thisPoint") %>%
    gather(points, point_distance, V1:ncol(.)) %>%
    arrange(as.numeric(thisPoint)) %>%
    group_by(thisPoint) %>%
    summarize(pointDistance = mean(point_distance)) %>%
    arrange(as.numeric(thisPoint)) %>% 
    dplyr::select(-thisPoint) %>%
    pull()
  
  return(output)  
}


rquery.wordcloud <- function(x, type=c("text", "url", "file"), 
                          lang="english", excludeWords=NULL, 
                          textStemming=FALSE,  colorPalette="Dark2",
                          min.freq=3, max.words=200)
{ 
  library("tm")
  library("SnowballC")
  library("wordcloud")
  library("RColorBrewer") 
  
  if(type[1]=="file") text <- readLines(x)
  else if(type[1]=="url") text <- html_to_text(x)
  else if(type[1]=="text") text <- x
  
  # Load the text as a corpus
  docs <- Corpus(VectorSource(text))
  # Convert the text to lower case
  docs <- tm_map(docs, content_transformer(tolower))
  # Remove numbers
  docs <- tm_map(docs, removeNumbers)
  # Remove stopwords for the language 
  docs <- tm_map(docs, removeWords, stopwords(lang))
  # Remove punctuations
  docs <- tm_map(docs, removePunctuation)
  # Eliminate extra white spaces
  docs <- tm_map(docs, stripWhitespace)
  # Remove your own stopwords
  if(!is.null(excludeWords)) 
    docs <- tm_map(docs, removeWords, excludeWords) 
  # Text stemming
  if(textStemming) docs <- tm_map(docs, stemDocument)
  # Create term-document matrix
  tdm <- TermDocumentMatrix(docs)
  m <- as.matrix(tdm)
  v <- sort(rowSums(m),decreasing=TRUE)
  d <- data.frame(word = names(v),freq=v)
  # check the color palette name 
  if(!colorPalette %in% rownames(brewer.pal.info)) colors = colorPalette
  else colors = brewer.pal(8, colorPalette) 
  # Plot the word cloud
  set.seed(1234)
  wordcloud(d$word,d$freq, min.freq=min.freq, max.words=max.words,
            random.order=FALSE, rot.per=0.35, 
            use.r.layout=FALSE, colors=colors)
  
  invisible(list(tdm=tdm, freqTable = d))
}
#++++++++++++++++++++++
# Helper function
#++++++++++++++++++++++
# Download and parse webpage
html_to_text<-function(url){
  library(RCurl)
  library(XML)
  # download html
  html.doc <- getURL(url)  
  #convert to plain text
  doc = htmlParse(html.doc, asText=TRUE)
 # "//text()" returns all text outside of HTML tags.
 # We also donâ€™t want text such as style and script codes
  text <- xpathSApply(doc, "//text()[not(ancestor::script)][not(ancestor::style)][not(ancestor::noscript)][not(ancestor::form)]", xmlValue)
  # Format text vector into one character string
  return(paste(text, collapse = " "))
}
```

```{r load data, include=FALSE, echo = TRUE, message = FALSE, warning = FALSE}

#listings <- st_read("listings.csv")
#details <- st_read("listings_details.csv")
#calendar <- read.csv("calendar.csv")


details <- read.csv("/Users/annzhang/Downloads/archive/listings_details.csv")
listings <- read.csv("/Users/annzhang/Downloads/archive/listings.csv")
calendar <- read.csv("/Users/annzhang/Downloads/archive/calendar.csv")


#large neighborhood
neighborhood <- st_read('neighbourhoods.geojson')

#small neighborhood
neighbor2 <- st_read('neighbor2.json') %>% 
  st_transform(st_crs(neighborhood))

developing_area <- st_read('developing_area.json') %>% 
  st_transform(st_crs(neighborhood))

crowdsensor <- st_read('crowdsensor.json') %>% 
  st_transform(st_crs(neighborhood))

metro <- st_read('tram_metro_stops.json') %>% 
  st_transform(st_crs(neighborhood))

buildingyear <- st_read('buildingyearblock.json') %>% 
  st_transform(st_crs(neighborhood))

zipcode6 <- st_read('zipcode6.json') %>% 
  st_transform(st_crs(neighborhood))

zipcode4 <- st_read('zipcode4.json') %>% 
  st_transform(st_crs(neighborhood))
```

```{r  text, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
details.sf <- st_as_sf(details,coords = c('longitude','latitude'),crs = 4326) %>% 
  st_transform(st_crs(neighborhood))

details.sf$price <- parse_number(details.sf$price)
details.sf$weekly_price <- parse_number(details.sf$weekly_price)
details.sf$monthly_price <- parse_number(details.sf$monthly_price)
details.sf$cleaning_fee <- parse_number(details.sf$cleaning_fee)
details.sf$extra_people <- parse_number(details.sf$extra_people)
details.sf$security_deposit <- parse_number(details.sf$security_deposit)
details.sf$beds <- as.numeric(details.sf$beds)
details.sf$minimum_nights <- as.numeric(details.sf$minimum_nights)
details.sf$maximum_nights <- as.numeric(details.sf$maximum_nights)
details.sf$number_of_reviews <- as.numeric(details.sf$number_of_reviews)
details.sf$review_scores_rating <- as.numeric(details.sf$review_scores_rating)
details.sf$review_scores_accuracy <- as.numeric(details.sf$review_scores_accuracy)
details.sf$review_scores_cleanliness<- as.numeric(details.sf$review_scores_cleanliness)
details.sf$review_scores_value <- as.numeric(details.sf$review_scores_value)
details.sf$reviews_per_month <- as.numeric(details.sf$reviews_per_month)
details.sf$id <- as.character(details.sf$id)
details.sf$property_type <- as.factor(details.sf$property_type)

details.sf.raw <- details.sf
```

# Exploratory Analysis

Since the Airbnb data already contains a lot of information (hiding many secrets!), we will first conduct exploratory analysis by examining location (geographic distribution) of available units, price per night, occupancy, room characteristics (composition, layout), and amenities that come with the room. Looking into those aspects can help our clients, future Airbnb host, to quickly identify internal characteristics of their unit and set price. It may also help those hosts who wish to upgrade their units figure out a potential increase in price after the upgrade. 

```{r price panel, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
# Available Calendar
available_calendar <- calendar %>%
  filter(available =="t")

available_calendar$listing_id <- as.character(available_calendar$listing_id)

# Price change
available_calendar <- available_calendar%>%
  mutate(price2 = gsub("^.","",price))%>%
  mutate(price2 = gsub(",","",price2))

available_calendar$price3 <- as.numeric(available_calendar$price2)

# Sum per month
available_calendar2 <- available_calendar%>%
  mutate(date2 = ymd(date))%>%
  mutate(month = month(date2))%>%
  group_by(listing_id, month) %>%
  dplyr::summarize(month_price = mean(price3))
```

```{r panel length, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
length(unique(calendar$listing_id))
length(unique(calendar$listing_id))*12
```

```{r deal with panel, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
study.panel <- 
  expand.grid(listing_id = unique(calendar$listing_id),
              month=unique(available_calendar2$month))
study.panel$listing_id <- as.character(study.panel$listing_id)
listing_panel <- study.panel %>%
  left_join(available_calendar2) %>%
  mutate(each_month_price = 0)
o <- order(listing_panel[,"listing_id"],listing_panel[,"month"])
listing_panel <- listing_panel[o,]
xx <- 0
for(i in 2:nrow(listing_panel)){
  if(!is.na(listing_panel[i,3])){
    xx <- listing_panel[i,3]
    listing_panel[i,4]=listing_panel[i,3]
  }
  if(is.na(listing_panel[i,3])& listing_panel[i-1,1]==listing_panel[i,1]){
    listing_panel[i,4] <- xx
  }
  if(is.na(listing_panel[i,3])& listing_panel[i-1,1]!=listing_panel[i,1]){
    xx <- 0
    listing_panel[i,4] <- xx
  }
}
d <- order(listing_panel[,"listing_id"],-listing_panel[,"month"])
listing_panel <- listing_panel[d,]
for(i in 2:nrow(listing_panel)){
  if(listing_panel[i,4]==0){
    listing_panel[i,4]=listing_panel[i-1,4]
  }
}
o <- order(listing_panel[,"listing_id"],listing_panel[,"month"])
listing_panel <- listing_panel[o,]
listing_0price <- listing_panel %>%
  filter(each_month_price == 0)
no_price <- unique(listing_0price$listing_id)

```

```{r drop NA listings, include=FALSE, echo = TRUE, message = FALSE, warning = FALSE}
#Filter data with no price
listing_panel <- listing_panel %>%
  filter(!listing_id %in% no_price)
```

## 1) Geographic Distribution

Firstly, identifying 'hotspots' would be helpful to have an overview of the Airbnb market in Amsterdam. On the one hand, the existing units are usually located in areas where tourists would want to stay, which equates to decent demand. On the other hand, adequate supply means there may be a competition in the market. 

Given city government's concern with too many Airbnb (short-term rental) concentrating in central historic areas, the maps below also help demonstrating how the market indeed is crammed in the central area. 

We choose to examin the distrbution at two scales -- neighborhood (identified by City of Amsterdam) and zipcode areas (smaller scale). Both maps show that many Airbnb are located along the canals, which is usually deemed signature of Amsterdam. 


```{r plot the number of airbnb, fig.width=6.4, fig.height=6.0, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
sf_use_s2(FALSE)
listings.sf<- listings %>% 
  st_as_sf(coords = c( "longitude","latitude"), crs = 4326, agr = "constant") %>% st_transform('ESRI:102013')

neighbor2 <- neighbor2 %>% 
  st_transform(st_crs(listings.sf))

listing.sf.neighbor2 <- st_intersection(listings.sf,neighbor2) %>% 
  dplyr::select(id, Buurt,Buurt_code) %>% 
  mutate(count=1) %>% 
  st_drop_geometry()

listings.sf <- left_join(listings.sf, listing.sf.neighbor2,by='id')

neighbo2.count <- listings.sf %>% 
  group_by(Buurt) %>%
  dplyr::summarise(airbnb.number = sum(count)) %>% 
  dplyr::select(Buurt, airbnb.number) %>% 
  st_drop_geometry()

neighbor2 <- left_join(neighbor2,neighbo2.count,by="Buurt")

ggplot()+
  geom_sf(data = neighbor2, aes(fill=q5(airbnb.number)),color='transparent')+
  scale_fill_manual(values = Teal,
                     labels = qBr(neighbor2,'airbnb.number'), name = 'Count')+
  labs(title = "Number of Airbnb per Neighborhood", subtitle = "Amsterdam, NL; 2018") +
  mapTheme()
```

```{r  fig.width=6.4, fig.height=6.0, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}


neighbor2 %>% ggplot() + 
      geom_sf(aes(fill = airbnb.number), color = 'white') +
      scale_fill_gradient(low = Teal[1], high = Teal[5],
                          name = "Count") +
      labs(title = "Number of Airbnb per Zipcode", subtitle = "Amsterdam, NL; 2018") +
      mapTheme()
```


## 2) Price

### Seasonality


```{r price change, fig.width=8, fig.height=3.8, include = TRUE, echo=TRUE, warning= FALSE, message=FALSE}
Month_price <- calendar%>%
  mutate(date2 = ymd(date))%>%
  mutate(month = month(date2),
         listing_id = as.character(listing_id),
         price = parse_number(price))%>%
  mutate(month = as.character(month))%>%
  mutate(month = ifelse(month != 10 & month != 11 & month != 12, gsub("^","0",month), month)) %>%
  drop_na(price) %>%
  group_by(month) %>%
  dplyr::summarize(mean_monthly_price = mean(price))


ggplot(Month_price, 
       aes(x=month, y=mean_monthly_price, group =1)) +
  geom_line(size=1, color = Teal[3]) +
  labs(title = "Average Airbnb Price Every Month", subtitle = "Amsterdam, NL; 2018") +
  xlab("Month of the Year") + ylab("Average Price") +
  plotTheme()
```

### Price per Bed

```{r plot price per bed, fig.width=6.4, fig.height=6.0, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
details.sf <- 
  details.sf %>% 
  mutate(priceBed=price/beds) %>% 
  filter(priceBed <=1000)


ggplot()+
  geom_sf(data = neighborhood,fill='grey95',color = 'white')+
  geom_sf(data = details.sf, aes(colour=q5(priceBed)),size=.5)+
  scale_color_manual(values = palette5,
                     labels = qBr(details.sf,'priceBed'), name="Price per Bed (Euro)") +
  labs(title = "Price per Bed",
       subtitle = 'Amsterdam Airbnb, price on 2018-12-6') +
  mapTheme()

```

## 3) Occupancy

```{r occupancy, fig.width=8, fig.height=3.8, include = TRUE, echo=TRUE, warning=FALSE, message=FALSE}
index <- function(x, flag = '0') {
  digit <- floor(log10(length(x))) + 1
  paste(flag, formatC(x, width = digit, flag = '0'), sep = '')
}

occupancy <- calendar%>%
  mutate(date2 = ymd(date))%>%
  mutate(month = month(date2),
         count = ifelse(available == "f", 1, 0),
         listing_id = as.character(listing_id))%>%
  filter(!listing_id %in% no_price) %>%
  group_by(listing_id, month) %>%
  dplyr::summarize(monthly_occupancy = sum(count))

monthly_occupancy <- occupancy %>%
  mutate(month = as.character(month))%>%
  mutate(month = ifelse(month != 10 & month != 11 & month != 12, gsub("^","0",month), month)) %>%
  group_by(month) %>%
  dplyr::summarise(mean_monthly_occupancy = mean(monthly_occupancy))

ggplot(monthly_occupancy, 
       aes(x=month, y=mean_monthly_occupancy, group =1)) +
  geom_line(size=1, color = "#FE9900") +
  labs(title = "Airbnb Occupancy Every Month", subtitle = "Amsterdam, NL; 2018") +
  xlab("Month of the Year") + ylab("Average Monthly Occupancy") +
  plotTheme()
```

## 4) Composition / Characteristics

### Room Layout

```{r basic features, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

table.basic <- details.sf %>% 
  st_drop_geometry() %>% 
  dplyr::select(price ,beds, bedrooms, bathrooms, accommodates)

stargazer(as.data.frame(table.basic),
          type = "text",
          title ="Table 1. Basic Features Summary",
          single.row = TRUE,
          out.header = TRUE)

```

### Property Type

```{r}
count(details.sf$property_type) %>%
  kable() %>%
  kable_styling() %>%
  scroll_box(width = "800px", height = "200px")

```

### Puting them together...

```{r include=TRUE}

details.sf %>%
  st_drop_geometry() %>%
  group_by(beds, bathrooms, bedrooms, accommodates, property_type) %>%
  dplyr::summarize(Mean_Price = mean(price)) %>%
  kable() %>%
  kable_styling() %>%
  scroll_box(width = "800px", height = "200px")

```

## 5) Amenities

```{r amenities, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
#pool
details.sf <- details.sf %>%
  mutate(pool = ifelse(str_detect(amenities, "Pool"), "Yes", "No"))

#Paid parking off premises
details.sf <- details.sf %>%
  mutate(parking = ifelse(str_detect(amenities, "Paid parking off premises"), 
                          "Yes", "No"))

#Indoor fireplace
details.sf <- details.sf %>%
  mutate(fireplace = ifelse(str_detect(amenities, "Indoor fireplace"), 
                          "Yes", "No"))

#Waterfront
details.sf <- details.sf %>%
  mutate(waterfront = ifelse(str_detect(amenities, "Waterfront"), 
                          "Yes", "No"))

#Kitchen
details.sf <- details.sf %>%
  mutate(kitchen = ifelse(str_detect(amenities, "Kitchen"), 
                          "Yes", "No"))

#Air conditioning
details.sf <- details.sf %>%
  mutate(AC = ifelse(str_detect(amenities, "Air conditioning"), 
                          "Yes", "No"))
```

```{r plot amenities,fig.width=10, fig.height=6.8, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
amenitie_vars <- c('fireplace','waterfront','pool','parking','kitchen','AC')
plotList <- list()

for (i in amenitie_vars){
plotList[[i]] <- 
  details.sf %>%st_drop_geometry() %>% 
  dplyr::select(price,i) %>%
  filter(price<500) %>% 
  gather(Variable, value, -price) %>%
    ggplot(aes(value, price, fill=value)) + 
      geom_boxplot() +
      scale_fill_manual(values = c("#FFDD94", "#CCABDB")) +
      labs(x="Amenity Status", y="Price",
           title = i) +
      theme(legend.position = "none") +
  plotTheme()
}

do.call(grid.arrange,c(plotList, ncol = 3, top = "Price w/ vs. w/o Amenities"))
```

### Aggregated Amenities:

In addition to each amenities listed above, we also included a feature named 'amenities.number' to explore the aggregated effect of amenities. Sometimes, regardless of specific types of amenities, simply the fact of having multiple amenities may increase the price visitors are willing to pay for an Airbnb.

```{r number of amenties listed, include=FALSE, echo = TRUE, message = FALSE, warning = FALSE}
library(stringr)

details.sf <- details.sf %>% 
  mutate(amenities.number = str_count(amenities,",")+1)

```

# New Features & Engineering

In addition to internal features that we examined earlier, we also want to take some external factors that are critical for tourists into considerations -- the neighborhood (area), distance to public transit stops, and distance to some tourists attractions (e.g. museums) and external amenities (supermarkets and convenience shops). As tourists can benefit a lot from close proximity to sites they want to visit or amenities, the price may go up for those units that are closer to those places. 


## New Feature 1: Spatial Lag & Neighborhood Effect

### Neighborhood Effect

```{r Neighborhood Effect, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE }
details.sf.neighbor <- st_intersection(details.sf,zipcode4) %>% 
  dplyr::select(id, Postcode4) %>% 
  st_drop_geometry()

details.sf <- left_join(details.sf,details.sf.neighbor,by='id')

```

```{r neighbor effect2 , include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
neighbor2 <- neighbor2 %>% 
  st_transform(st_crs(listings.sf))

listing.sf.neighbor2 <- st_intersection(listings.sf,neighbor2) %>% 
  dplyr::select(id, Buurt,Buurt_code) %>% 
  mutate(count=1) %>% st_drop_geometry()

listing.sf.neighbor2$id <- as.character(listing.sf.neighbor2$id)

detail.sf <- left_join(details.sf,listing.sf.neighbor2, by = "id")
```

### Spatial Lag

```{r occupancy join, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
occupancy3 <- occupancy %>%
  dplyr::rename(id = listing_id) 
  
occupancy3 <-  
  left_join(occupancy3, st_drop_geometry(details.sf), by = "id")
```

```{r price by month, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
listing_panel <- listing_panel%>%
   dplyr::rename(id = listing_id)

revenue_panel <- merge(occupancy3,listing_panel[c("id","month","each_month_price")],by=c("id","month")) %>%
  mutate(revenue = each_month_price*monthly_occupancy)
```

```{r correlation matrix, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

annualrevenue <- revenue_panel %>%
  group_by(id) %>%
  dplyr::summarise(annual_revenue = sum(revenue))


annualrevenue<- left_join(details.sf, annualrevenue,by="id")%>%
    filter(!id %in% no_price)%>%
    mutate(bathrooms = as.numeric(bathrooms),
         bedrooms = as.numeric(bedrooms))
```

```{r annual revenue spatial lag, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

annualrevenue<- annualrevenue %>%
  drop_na(annual_revenue) %>%
  filter(annual_revenue <= 500000)

coords <- st_coordinates(annualrevenue) 

neighborList <- knn2nb(knearneigh(coords, 5))

spatialWeights <- nb2listw(neighborList, style="W")


annualrevenue$lagRevenue <- lag.listw(spatialWeights, annualrevenue$annual_revenue)

```

```{r annual revenue & spatial lag plot, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
ggplot(annualrevenue)+
  geom_point(aes(x = lagRevenue, y = annual_revenue), alpha = 0.26)+
  geom_smooth(aes(x = lagRevenue, y =annual_revenue), method = "lm", se= FALSE, color = "orange")+
  labs(title="Annual Revenue as a function of lagRevenue", y='Annual Revenue', x = 'Lag Annual Revenue') +
  plotTheme()
```

## New Feature 2: Access to Public Transit

```{r}
listings$longitude = as.numeric(listings$longitude)
listings$latitude = as.numeric(listings$latitude)
listings.sf<- listings %>% 
  st_as_sf(coords = c( "longitude","latitude"), crs = 4326, agr = "constant")

st_crs(metro) <- st_crs(listings.sf)

st_c <- st_coordinates

details.sf.c <- details.sf %>%
  st_transform('ESRI:102013') 

metro.c <- metro%>%
  st_transform('ESRI:102013') 


```

```{r}
ggplot()+
  geom_sf(data = neighbor2, aes(fill=q5(airbnb.number)),color='transparent') +
  scale_fill_manual(values = Pink,
                     labels = qBr(neighbor2,'airbnb.number'), name = 'Count of Airbnb') +
  geom_sf(data=metro.c$geometry, aes(color=metro.c$Modaliteit)) +
  scale_color_manual(values=c(palette2[1], '#7171C6'), name = 'Type of Transit') +
  labs(title = "Public Transit & Number of Airbnb", subtitle = "Amsterdam, NL; 2018") +
  mapTheme()
```

```{r Metro Buffer}

#multi-ring buffer 
Metro_MRB <- multipleRingBuffer(st_union(metro.c), 6500, 500)

#USE FOR REG: MRB Spatial Join 
details.sf.c.MetroRings <-
  st_join(dplyr::select(details.sf.c, id),
          Metro_MRB) %>%
  st_drop_geometry() %>% 
  left_join(details.sf.c, annualrevenue,
            by="id") %>%
  st_sf()%>%
  mutate(metro.dist = distance/1000)

#Adding the variable to the data set
details.sf <- 
  left_join(details.sf, details.sf.c.MetroRings %>% st_drop_geometry() %>% dplyr::select(metro.dist, id), by="id") %>%
  dplyr::rename(metro.dist = distance)
  
#FOR VIS ONLY: Creating a summary table of the ring data 
details.Rings.Summary <- details.sf.c.MetroRings %>%
  dplyr::select(metro.dist, price)%>%
  st_drop_geometry()%>%
  group_by(metro.dist)%>%
  dplyr::summarize(Price=median(price, na.rm=T))

#FOR VIS ONLY: Line Plot of the summary table 
ggplot(data=details.Rings.Summary, aes(x=metro.dist, y=Price),)+
  geom_line(size=1.5)+
  geom_point(size = 3)+  
  labs(title = "Price as a Function of Distance from a Metro Station", 
       subtitle = "Amsterdam Airbnb Data, 2018", 
       x="Distance from a Metro Station (KM)",
       y="Rent (2018 Euro)")+
  theme(plot.title = element_text(size=18))
```

```{r}

annualrevenue <-
  annualrevenue %>%
  left_join(details.sf.c.MetroRings %>% st_drop_geometry %>% dplyr::select(metro.dist, id), by = 'id')

```



## New Feature 3: Proximity to Tourist Amenities

```{r outside attractions,  include=TRUE, echo = TRUE, message = FALSE, warning = FALSE, results='hide'}
unesco <-
  #st_read('UnescoWerelderfgoed_region.shp') %>%
  st_read('geojson_lnglat.json') %>%
  st_transform('ESRI:102013')

parks <- st_read('parks.json') %>% 
  st_transform('ESRI:102013')

attraction <- st_read('amsterdam-attraction.csv') %>% 
  filter(lat != 'attraction')
attraction <- st_as_sf(attraction,coords = c('lng','lat'),crs = 4326) %>% 
  st_transform('ESRI:102013')

parks <- attraction %>% 
  filter(subCategory == 'Park')

museum <- attraction %>% 
  filter(subCategory == 'Museum')

```

```{r outside amenities , include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

#supermarkets
supermarkets <- getbb('Amsterdam') %>% 
  opq() %>% 
  add_osm_feature('shop','supermarket') %>% 
  osmdata_sf() 
supermarkets <- supermarkets$osm_points %>% 
  dplyr::select(geometry)%>% 
  st_transform('ESRI:102013')%>% 
  dplyr::select(geometry) %>% 
  mutate(Legend = "supermarkets")

convenienceshop <- getbb('Amsterdam') %>% 
  opq() %>% 
  add_osm_feature('shop','convenience') %>% 
  osmdata_sf() 
convenienceshop <- convenienceshop$osm_points %>% 
  dplyr::select(geometry)%>% 
  st_transform('ESRI:102013')%>% 
  dplyr::select(geometry) %>% 
  mutate(Legend = "convenienceshop")

mall <- getbb('Amsterdam') %>% 
  opq() %>% 
  add_osm_feature('shop','mall') %>% 
  osmdata_sf() 
mall<- mall$osm_points %>% 
  dplyr::select(geometry)%>% 
  st_transform('ESRI:102013') %>% 
  dplyr::select(geometry) %>% 
  mutate(Legend = "mall")


attraction <- st_as_sf(attraction,coords = c('lng','lat'),crs = 4326) %>% 
  st_transform('ESRI:102013')


plaza <- attraction %>% 
  filter(subCategory == 'Plaza') 


beach <- attraction %>% 
  filter(subCategory == 'Beach') 


nightclub <- attraction %>% 
  filter(subCategory == 'Nightclub') 

```

```{r calculate distance to amenities & attractions , include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

dist <- 1000

details.sf.c.attractions <- details.sf %>%
  dplyr::select(id)

#malls
mallBuffer <- st_union(st_buffer(mall, dist))%>%
    st_sf()

details.sf.c.attractions <- 
  rbind(
    details.sf.c[mallBuffer,] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(mall.close = "y"),
    details.sf.c[mallBuffer, op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(mall.close = "n"))
  
#supermarkets
supermarketsBuffer <- st_union(st_buffer(supermarkets, dist))%>%
    st_sf()

details.sf.c.attractions <- 
  rbind(
    details.sf.c[supermarketsBuffer,] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(supermarkets.close = "y"),
    details.sf.c[supermarketsBuffer, op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(supermarkets.close = "n"))

#dist.convenienceshop

details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(convenienceshop, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(convenienceshop.close = "y"),
    details.sf.c[st_union(st_buffer(convenienceshop, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(convenienceshop.close = "n"))

#dist.museum
details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(museum, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(museum.close = "y"),
    details.sf.c[st_union(st_buffer(museum, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(museum.close = "n"))

#dist.plaza
details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(plaza, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(plaza.close = "y"),
    details.sf.c[st_union(st_buffer(plaza, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(plaza.close = "n"))

#dist.nightclub
details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(nightclub, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(nightclub.close = "y"),
    details.sf.c[st_union(st_buffer(nightclub, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(nightclub.close = "n"))

#dist.beach
details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(beach, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(beach.close = "y"),
    details.sf.c[st_union(st_buffer(beach, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(beach.close = "n"))

#dist.parks
details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(parks, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(parks.close = "y"),
    details.sf.c[st_union(st_buffer(parks, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(parks.close = "n"))

details.sf.attractions <-
  left_join(details.sf, st_drop_geometry(details.sf.c.attractions), by="id")

```

```{r}
table.distance <- details.sf.attractions %>% 
  st_drop_geometry() %>% 
  dplyr::select(price.y, museum.close,plaza.close,nightclub.close,beach.close,
                  supermarkets.close, parks.close, mall.close, convenienceshop.close)

table.distance %>%
  gather(Variable, value, -price.y) %>%
    ggplot(aes(value, price.y, fill=value)) + 
      geom_bar(position = "dodge", stat = "summary", fun = "mean") + 
      facet_wrap(~Variable, scales = "free") +
      scale_fill_manual(values = palette2) +
      labs(x="Within 1KM?", y="Average Price", 
           title = "Feature Associations with Proximity to Attractions",
           subtitle = "Amsterdam Airbnbs, 2018") +
      theme(legend.position = "none")
```

```{r}


annualrevenue <-
  annualrevenue %>%
  left_join(details.sf.c.attractions %>% st_drop_geometry %>% dplyr::select(id, convenienceshop.close, mall.close, museum.close, plaza.close, supermarkets.close), by = 'id')

```



# Feature Review: Correlation Matrix

```{r numeric correlation matrix, fig.width=6.4, fig.height=6.0, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
numericVars <- 
  select_if(st_drop_geometry(annualrevenue), is.numeric) %>% na.omit() %>% 
  dplyr::select(annual_revenue,price,beds, bedrooms, bathrooms, 
                              minimum_nights,
                              amenities.number, metro.dist)

ggcorrplot(
  round(cor(numericVars), 1), 
  p.mat = cor_pmat(numericVars),
  colors = c("#4757a2", "white", "#E46B45"),
  type="lower",
  insig = "blank") +  
    labs(title = "Correlation across numeric variables") 
```

# Regression Model

We are using linear regression model for this machine learning task. 

## Data Split: Testing & Training

```{r annual revenue regression, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
annualrevenue <- merge(annualrevenue,listing.sf.neighbor2[c("id", "Buurt")], by = "id")
```

```{r}
#Split training and test set
annualrevenue <- annualrevenue%>% st_drop_geometry()
set.seed(31497)

inTrain <- caret::createDataPartition(
  y =  paste(annualrevenue$Buurt),
  p = .6, list = FALSE)

annualrevenue.training <- st_drop_geometry(annualrevenue)[inTrain,]
annualrevenue.test     <- st_drop_geometry(annualrevenue)[-inTrain,]
```

## Regression Results

```{r}

reg.annualrevenue <- lm(price ~ ., data = st_drop_geometry(annualrevenue) %>% 
             dplyr::select(price, beds, bedrooms, bathrooms, accommodates,
                              pool, parking, kitchen, AC, fireplace,
                              room_type,property_type,bed_type, Buurt,
                              minimum_nights, convenienceshop.close, mall.close, museum.close,
                              plaza.close, supermarkets.close,
                              amenities.number,lagRevenue, metro.dist)) 

stargazer(reg.annualrevenue,
          type = "text",
          title ="Regression Output",
          single.row = TRUE,
          out.header = TRUE)

```

```{r annual revenue regression summ, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

annualrev_predict_test <- annualrevenue.test %>%
  mutate(Prediction = predict(reg.annualrevenue, newdata = annualrevenue.test)) %>%
  mutate(Prediction = ifelse(Prediction > 0, Prediction, mean(annualrevenue.training$price)))%>%
  filter(price!=0)%>%
  drop_na(Prediction)%>%
  mutate(AE = abs(Prediction-price),
         APE = AE/Prediction)

test_result <- data.frame(MAE = c(mean(annualrev_predict_test$AE, na.rm=T)),
              MAPE = c(scales::percent(mean(annualrev_predict_test$APE, na.rm=T)))) 

test_result %>%
  kable(caption = "Figure 8. Mean absolute error and MAPE for a single test set")%>%
  kable_styling("striped", full_width = F)
```

## MAPE (Mean Absolute Percentage Error)

```{r  annual revenue regression plot by Buurt, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
palette5 <- c("#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404")

annualrev_predict_test%>%
  group_by(Buurt) %>%
  dplyr::summarize(mean.APE = mean(APE, na.rm = T)) %>%
  ungroup() %>% 
  left_join(neighbor2,by = "Buurt") %>%
    st_sf() %>%
    ggplot() + 
      geom_sf(aes(fill = mean.APE),colour = 'transparent') +
      scale_fill_gradient(low = palette5[1], high = palette5[5],
                          name = "MAPE") +
      labs(title = "Average Test Set MAPE"
           #,subtitle = "2019"
           ) +
      mapTheme()

```

# Cross Validation: LOGO (Leave One Group Out)

LOGO (Leave One Group Out) is a type of cross validation that is similar to K-fold but takes spatial aspects into consideration -- taking one neighborhood out at a time for cross validating. Since the airbnb location is critical in this project, we think LOGO would be a more suitable way for testing out our model. Here we use 481 'buurt (buurten)' (neighborhood in dutch) defined by the city. 

```{r results='hide', message=FALSE, warning=FALSE}


reg.vars <- c("beds", "bedrooms", "bathrooms", "accommodates",
                              "pool", "parking", "kitchen", "AC", "fireplace",
                              "room_type",  "bed_type",
                              "amenities.number","lagRevenue", "convenienceshop.close", "mall.close",
                              "museum.close",
                              "plaza.close", "supermarkets.close")

airbnb.location <- details.sf %>% dplyr::select(id)

annualrev_predict_test <- annualrev_predict_test %>% left_join(airbnb.location, by='id')
colnames(annualrev_predict_test)[1] =  "identifier"

reg.spatialCV <- crossValidate(
  dataset = annualrev_predict_test,
  id = "Buurt",
  dependentVariable = "price",
  indVariables = reg.vars) %>%
    dplyr::select(identifier = Buurt, price, Prediction, geometry)

```

```{r message=FALSE, warning=FALSE}

reg.spatialCV <-
  reg.spatialCV %>%
  mutate(Error = Prediction - price)

error_by_reg_and_fold <-
  reg.spatialCV  %>%
  group_by(identifier) %>%
  dplyr::summarize(Mean_error = mean(Error, na.rm=T),
                   MAE = mean(abs(Mean_error), na.rm=T),
                   SD_MAE = mean(abs(Mean_error), na.rm=T)) %>%
  ungroup()

st_drop_geometry(error_by_reg_and_fold) %>%
    dplyr::summarize(Mean_MAE = round(mean(MAE), 2),
              SD_MAE = round(sd(MAE), 2)) %>%
  kable() %>%
    kable_styling("striped", full_width = F) 

```

From the LOGO-CV result, our mean absolute error is 25.1 euro, with a 23.77 euro standard deviation. This means that on average our prediction could be 25.1 euro off, higher or lower. Given our predictability being ~42%, this is an expected and acceptable error to be observed.

Since earlier we observed a clustering in central areas, we are curious to see how our model performs in areas with more existing Airbnb vs. less. Hence we split neighborhoods into those with more than 50 Airbnb vs. less than 50, checked the respective mean absolute error for the high vs. low count groups, then plotted the mean error in each neighborhood. 


```{r}
#Counting per neighborhood
neighbourhoodCount <- annualrevenue %>%
  dplyr::count(Buurt)

#Joining to new spatial db
neighbourhoodHL <- neighbor2 %>%
  left_join(st_drop_geometry(neighbourhoodCount), by = "Buurt")%>%
  mutate(Airbnb1k = ifelse(n < 50, "Low", "High"))

#spatial join of the essential comparison data
st_join(error_by_reg_and_fold, neighbourhoodHL) %>% #fill in data frame with error column here
  group_by(Airbnb1k) %>%
  dplyr::summarize(mean.MAE = scales::percent(mean(MAE, na.rm = T))) %>% #fill in error column here
  st_drop_geometry() %>%
  spread(Airbnb1k, mean.MAE) %>%
  kable(caption = "<strong>Test set MAE within Neighborhoods Above or Below 50 Listings </strong>")%>%
  kable_styling()
```

The mean absolute error in area with higher count of Airbnb is significantly lower than the area with lower count, according to the data. The map below has lower-count areas in grey shade. By comparing shaded (lower count) to unshaded (higher count) areas, we can see that the shaded areas have more variation while the unshaded areas have mean errors closer to zero -- suggesting a better performance in higher count area. 

```{r}
colnames(error_by_reg_and_fold)[1] = "Buurt"

new <-
  neighbor2 %>% dplyr::select(Buurt, geometry) %>%
  left_join(st_drop_geometry(error_by_reg_and_fold), by = 'Buurt')
  

Low_Count_Boundary <-
  st_union(neighbourhoodHL %>% filter(Airbnb1k == 'Low'))

  ggplot() +
  geom_sf(data=new, aes(fill=Mean_error), size=0.3) +
  scale_fill_gradient(low = '#91bfdb', high = '#fc8d59', na.value = 'white', name = "Mean Error") +
  labs(title = "Mean Error (LOGO-CV)", subtitle = "Amsterdam, NL") + 
  geom_sf(data=Low_Count_Boundary, color="black", fill = mycol, size=0.7) + mapTheme() 


  mycol <- rgb(220,220,220, max = 255, alpha = 90, names = "blue50")
```

# Conclusion

In conclusion, our model gives a decent prediction for airbnb price in Amsterdam, although for it to be implemented, we would need more upgrades and feature engineering. From the results of cross validation, our model is better predicting price in areas with higher concentration of existing Airbnb in comparison to lower density areas, given the fact that more existing data is provided. 




